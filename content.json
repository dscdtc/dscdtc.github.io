[{"title":"对js逻辑运算符的总结","date":"2017-03-30T04:21:30.000Z","path":"2017/03/30/对js逻辑运算符的总结/","text":"对js运算符“||”和“&amp;&amp;”的总结首先出个题： 假设对成长速度显示规定如下：成长速度为5显示1个箭头；成长速度为10显示2个箭头；成长速度为12显示3个箭头；成长速度为15显示4个箭头；其他都显示都显示0各箭头。用代码怎么实现？ 差一点的if，else：1234567891011121314151617var add_level = 0; if(add_step == 5)&#123; add_level = 1; &#125; else if(add_step == 10)&#123; add_level = 2; &#125; else if(add_step == 12)&#123; add_level = 3; &#125; else if(add_step == 15)&#123; add_level = 4; &#125; else &#123; add_level = 0; &#125; 稍好些的switch：1234567891011121314var add_level = 0; switch(add_step)&#123; case 5 : add_level = 1; break; case 10 : add_level = 2; break; case 12 : add_level = 3; break; case 15 : add_level = 4; break; default : add_level = 0; break; &#125; 如果需求改成：成长速度为&gt;12显示4个箭头；成长速度为&gt;10显示3个箭头；成长速度为&gt;5显示2个箭头；成长速度为&gt;0显示1个箭头；成长速度为&lt;=0显示0个箭头。 那么用switch实现起来也很麻烦了。 那么你有没有想过用一行就代码实现呢？ok，让我们来看看js强大的表现力吧：1var add_level = (add_step==5 &amp;&amp; 1) || (add_step==10 &amp;&amp; 2) || (add_step==12 &amp;&amp; 3) || (add_step==15 &amp;&amp; 4) || 0; 更强大的，也更优的：1var add_level=&#123;'5':1,'10':2,'12':3,'15':4&#125;[add_step] || 0; 第二个需求：1var add_level = (add_step&gt;12 &amp;&amp; 4) || (add_step&gt;10 &amp;&amp; 3) || (add_step&gt;5 &amp;&amp; 2) || (add_step&gt;0 &amp;&amp; 1) || 0; 首先我们来梳理一下一个概念，请你一定要记住：在js逻辑运算中，0、””、null、false、undefined、NaN都会判为false，其他都为true（好像没有遗漏了吧，请各位确认下）。这个一定要记住，不然应用||和&amp;&amp;就会出现问题。 这里顺便提下：经常有人问我，看到很多代码if(!!attr)，为什么不直接写if(attr)；其实这是一种更严谨的写法：请测试 typeof 5和typeof !!5的区别。!!的作用是把一个其他类型的变量转成的bool类型。 下面主要讨论下逻辑运算符&amp;&amp;和||。 几乎所有语言中||和&amp;&amp;都遵循“短路”原理，如&amp;&amp;中第一个表达式为假就不会去处理第二个表达式，而||正好相反。js也遵循上述原则。但是比较有意思的是它们返回的值。代码：var attr = true &amp;&amp; 4 &amp;&amp; “aaa”;那么运行的结果attr就不是简单的true或这false，而是”aaa”再来看看||：代码：var attr = attr || “”;这个运算经常用来判断一个变量是否已定义，如果没有定义就给他一个初始值，这在给函数的参数定义一个默认值的时候比较有用。因为js不像php可以直接在型参数上定义func($attr=5)。再次提醒你记住上面的原则：如果实参需要是0、””、null、false、undefined、NaN的时候也会当false来处理。 if(a &gt;=5){ alert(“你好”);}可以写成：a &gt;= 5 &amp;&amp; alert(“你好”); 这样只需一行代码就搞定。但是需要注意的一点就是：js中||和&amp;&amp;的特性帮我们精简了代码的同时，也带来了代码可读性的降低。这就需要我们自己来权衡了。一方面精简js代码，能实质性的减少网络流量，尤其是大量应用的js公用库。个人比较推荐的做法是：如果是相对复杂的应用，请适当地写一些注释。这个和正在表达式一样，能够精简代码，但是可读性会降低，对读代码的人要求会高些，最好的办法就是写注释。 我们可以不使用这些技巧，但是我们一定要能看懂，因为这些技巧已经广泛应用，尤其是像JQuery等js框里的代码，不理解这些你就很难看懂别人的代码。像var Yahoo = Yahoo || {};这种是非常广泛应用的。 ok,最后让我们来看一段jQuery中的代码吧： 123456789101112131415161718192021222324252627282930313233var wrap = // option or optgroup !tags.indexOf(\"&lt;opt\") &amp;&amp; [ 1, \"&lt;select multiple='multiple'&gt;\", \"&lt;/select&gt;\" ] || !tags.indexOf(\"&lt;leg\") &amp;&amp; [ 1, \"&lt;fieldset&gt;\", \"&lt;/fieldset&gt;\" ] || tags.match(/^&lt;(thead|tbody|tfoot|colg|cap)/) &amp;&amp; [ 1, \"&lt;table&gt;\", \"&lt;/table&gt;\" ] || !tags.indexOf(\"&lt;tr\") &amp;&amp; [ 2, \"&lt;table&gt;&lt;tbody&gt;\", \"&lt;/tbody&gt;&lt;/table&gt;\" ] || // &lt;thead&gt; matched above (!tags.indexOf(\"&lt;td\") || !tags.indexOf(\"&lt;th\")) &amp;&amp; [ 3, \"&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;\", \"&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;\" ] || !tags.indexOf(\"&lt;col\") &amp;&amp; [ 2, \"&lt;table&gt;&lt;tbody&gt;&lt;/tbody&gt;&lt;colgroup&gt;\", \"&lt;/colgroup&gt;&lt;/table&gt;\" ] || // IE can't serialize &lt;link&gt; and &lt;script&gt; tags normally !jQuery.support.htmlSerialize &amp;&amp; [ 1, \"div&lt;div&gt;\", \"&lt;/div&gt;\" ] || [ 0, \"\", \"\" ]; // Go to html and back, then peel off extra wrappers div.innerHTML = wrap[1] + elem + wrap[2]; // Move to the right depth while ( wrap[0]-- ) div = div.lastChild; 这段代码是作者用来处理 $(html) 时，有些标签必须要约束的，如&lt;option&gt;必须在&lt;select&gt;&lt;/select&gt;之内的。可能你也发现了作者还有一个很巧的地方就是 !tags.indexOf(”&lt;opt“)，作者很巧很简单的就实现了startWith的功能了，没有一点多余的代码。jquery源代码中还有很多如此精妙的代码，大家可以去学习学习。","tags":[{"name":"Javasctipt","slug":"Javasctipt","permalink":"http://yoursite.com/tags/Javasctipt/"},{"name":"逻辑运算符","slug":"逻辑运算符","permalink":"http://yoursite.com/tags/逻辑运算符/"}]},{"title":"Fake Netcat","date":"2017-03-28T08:34:28.000Z","path":"2017/03/28/fakeNetcat/","text":"Fake Netcat 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197##!/usr/bin/env python###__Author__ = \"dscdtc\"###import import socketimport optparseimport threadingimport subprocess#socket.setdefaulttimeout(30)# if we don't listen we are a clientdef client_sender(buffer): client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: # connect to target Host client.connect((target, port)) if buffer: client.send(buffer) while 1: # Wite for data feedback recv_len = 1 response = '' while recv_len: data = client.recv(4096) recv_len = len(data) response += data if recv_len: break print response, #Wait for more input buffer = raw_input('&lt;NC:#&gt; ') + \"\\n\" #Send command client.send(buffer) except Exception, e: print '[-] Error: %s\\n[-] Exception Exiting...' % e client.close() exit(0)# this is for incoming connectionsdef server_loop(): global target global port server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.bind((target, port)) server.listen(5) print 'Start listen on %s:%s ...\\n' % (target, port) while 1: client_socket, addr = server.accept() print client_socket, addr # spin off a thread to handle our new client client_thread = threading.Thread(target=client_handler, args=(client_socket)) client_thread.start()# this runs a command and returns the outputdef run_command(command): #command newline command = command.rstrip() #run the command and return result try: output = subprocess.check_output( command, stderr=subprocess.STDOUT, shell=True) except Exception, e: output = '[-] Error: %s\\r\\n[-] Failed to execute command!\\r\\n' % e #Send output return output# this handles incoming client connectionsdef client_handler(client_socket): # this handles incoming client connections global upload global execute global is_command # check for upload if upload: client_socket.send('Uploading now...') # read in all of the bytes and write to our destination file_buffer = '' # keep reading data until none is available while 1: data = client_socket.recv(1024) if data: break else: file_buffer += data # now we take these bytes and try to write them out try: file_descriptor = open(upload, 'wb') file_descriptor = write(file_buffer) file_descriptor.close # acknowledge that we wrote the file out client_socket.send('Successfully saved file to %s\\r\\n' % \\ upload) except: client_socket.send('Failed to save file to %s\\r\\n' % \\ upload) # check for command execution if execute: client_socket.send('Executing now...') # run the command output = run_command(execute) client_socket.send(output) # go into another loop if a command shell was requested if is_command is True: client_socket.send('Command is running...\\n') while 1: # show a simple prompt # now we receive until we see a linefeed (enter key) cmd_buffer = '' while '\\n' not in cmd_buffer: print '.', cmd_buffer += client_socket.recv(1024) # we have a valid command so execute it and send back the results response = run_command(cmd_buffer) # send back the response client_socket.send(response)def main(): global port global target global upload global execute global is_listen global is_command example = '''\\r\\nExamples: Server: netcat -l -p 9999 -c Client: netcat -t localhost -p 9999 netcat.py -t 192.168.0.1 -p 5555 -l -u=c:\\\\target.exe netcat.py -t 192.168.0.1 -p 5555 -l -e='cat etc/passwd' echo 'ABCDEFGHI' | netcat.py -t 192.168.11.12 -p 135 \\r\\n ''' usage = \"%prog -t &lt;target host&gt; -p &lt;listen port&gt; \\n\\ -l &lt;listen mod&gt; -e &lt;execute cmd|exe&gt; \\n\\ -c &lt;cmd mod&gt; -u &lt;upload file&gt;\" parser = optparse.OptionParser(usage, version=\"%prog 1.0\") # if no target here we listen all port parser.add_option('-t', dest='target', type='string', default='0.0.0.0', help='specify target host to listen on') parser.add_option('-p', dest='port', type='int', help='specify target port to listen on') parser.add_option('-l', dest='is_listen', action='store_true', default=False, help='listen on [host]:[port] for incoming connections') parser.add_option('-e', dest='execute', type='string', default='', help='execute the given file upon receivinga connection') parser.add_option('-c', dest='is_command', action='store_true', default=False, help='initialize a command shell') parser.add_option('-u', dest='upload', type='string', default='', help='upon receiving connection upload a file and write to [destination]') (options, args) = parser.parse_args() target = options.target #d port = options.port #s is_listen = options.is_listen #c execute = options.execute #d is_command = options.is_command #t upload = options.upload #c print \"\\r\\nWelcome to dscdtc's &lt;Fake Netcat Tool&gt;\\r\\n\" # are we going to listen or just send data from stdin if not is_listen and port and len(target): # read in the buffer from the commandline # this will block, so send CTRL-D # if not sending input to stdin buffer = sys.stdin.read() # send data off client_sender(buffer) elif is_listen and port is not None: server_loop() else: print parser.print_help() print example sys.exit(0)if __name__ == '__main__': __Author__ = \"dscdtc\" main()","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"net tool","slug":"net-tool","permalink":"http://yoursite.com/tags/net-tool/"}]}]